#######################################################################
# Test for copying block of size 63;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $63, %rdx		# src and dst have 63 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
	call ncopy		 
	halt			# should halt with num nonzeros in %rax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Wang, Chen
# 16307110064
#
# Describe how and why you modified the baseline code.
# The original baseline code is modified in great extension from the following 
# four perspectives:
# 1. The straightforward loop is unrolled into eight continuous executions.
# Therefore, if the data is longer than 8, each loop will do eight continuous
# copy actions, which can greatly reduce the number of iterations thus reducing 
# the condition control overhead.
# 2. There is usually the case that there are remainders that is not a multiple 
# of eight. In this case, I just made the copy execution in a straight line way
# without any iterations. This can reduce the control overhead for this part.
# 3. Each condition jump is placed and designed carefully to make the prediction 
# have the best correct possibilities.
# 4. For the remaining parts, avoiding data hazard is also paid attention to
# so as to elevate the efficiency.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
# Loop header
    iaddq $-8, %rdx         # len = len - 7
	jle Remaining                 # if len > 0, then go to Loop

########-----Loop Separator-------################################

Loop:
	mrmovq (%rdi), %rcx	    # save the first element from memory to register %rcx
	iaddq $72, %rdi		    # src = src + 9 (move 72 bytes, i.e. 8 words forward)
	iaddq $72, %rsi			# dst = dst + 9 (move 72 bytes, i.e. 8 words forward)
	mrmovq -64(%rdi), %r8	# save the second element from memory to register %r8
	rmmovq %rcx, -72(%rsi)  # save the value to the destination memory
	andq %rcx, %rcx		    # test %rcx
	jle LoopJmp1			# if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax		    # add the number of postive numbers

LoopJmp1:
	mrmovq -56(%rdi), %r9   # to avoid load/use hazard, this read memory instruction is advanced
	rmmovq %r8, -64(%rsi)	# save the second value to the destination memory
	andq %r8, %r8			# test for future reference
	mrmovq -48(%rdi), %r10  # to avoid load/use hazard, this read memory instruction is advanced
	jle LoopJmp2			# if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax			# add the number of postive numbers

LoopJmp2:
	rmmovq %r9, -56(%rsi)   # save the third value to the destination memory
	andq %r9, %r9           # test for future reference
	mrmovq -40(%rdi), %r11  # to avoid load/use hazard, this read memory instruction is advanced
	jle LoopJmp3            # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp3:
	rmmovq %r10, -48(%rsi)  # save the forth value to the destination memory
	andq %r10, %r10         # test for future reference
	jle LoopJmp4            # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp4:
	rmmovq %r11, -40(%rsi)  # save the fifth value to the destination memory
	mrmovq -32(%rdi), %r8   # to avoid load/use hazard, this read memory instruction is advanced
	andq %r11, %r11         # test to see if the value is no greater than 0
	jle LoopJmp5
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp5:
	rmmovq %r8, -32(%rsi)   # save the sixth value to the destination memory
	andq %r8, %r8           # test for future reference
	mrmovq -24(%rdi), %r9   # to avoid load/use hazard, this read memory instruction is advanced
	jle LoopJmp6            # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp6:
	rmmovq %r9, -24(%rsi)   # save the seventh value to the destination memory
	mrmovq -16(%rdi), %r10   # to avoid load/use hazard, this read memory instruction is advanced
	andq %r9, %r9           # test for future reference
	jle LoopJmp7            # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp7:
	rmmovq %r10, -16(%rsi)   # save the seventh value to the destination memory
	mrmovq -8(%rdi), %r11   # to avoid load/use hazard, this read memory instruction is advanced
	andq %r10, %r10           # test for future reference
	jle LoopJmp8            # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp8:
	rmmovq %r11, -8(%rsi)   # save the eighth value to the destination memory
	andq %r11, %r11         # test to see if the value is no greater than 0
	jle LoopJmp9
	iaddq $1, %rax          # add the number of postive numbers

LoopJmp9:
	iaddq $-9, %rdx			# len - 9 and then len > 0 ?
	jg Loop					# if so, the loop will continue

########-----Loop Separator-------################################


Remaining:
    iaddq $8, %rdx
    jg Continue
    ret

Continue:
    mrmovq (%rdi), %rcx		# save the first element from memory to register %rcx
    iaddq $-1, %rdx         # len = len - 1
    jg RemAddFirstNotEnd    # if len > 0, then the work is not finished yet

RemAddFirstEnd:
    rmmovq %rcx, (%rsi)		# save the value to the destination memory
    andq %rcx, %rcx			# test *src to see whether the value is less than 0
    jle Done                # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers
    ret

RemAddFirstNotEnd:
    rmmovq %rcx, (%rsi)		# save the value to the destination memory
    andq %rcx, %rcx			# test *src to see whether the value is less than 0
    jle RemAdd1             # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

RemAdd1:
    mrmovq 8(%rdi), %r8		# save the second element from memory to register %r8
    mrmovq 16(%rdi), %r9	# save the third element from memory to register %r9
    rmmovq %r8, 8(%rsi)		# save the value to the destination memory
    andq %r8, %r8			# test *src to see whether the value is less than 0
    jle RemComp2            # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

RemComp2:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd2              # if len > 0, then the work is not finished yet
	ret

RemAdd2:
    mrmovq 24(%rdi), %r10	# save the forth element from memory to register %r10
    rmmovq %r9, 16(%rsi)	# save the value to the destination memory
    andq %r9, %r9           # test *src to see whether the value is less than 0
    jle RemComp3            # if not greater than 0, jump
    iaddq $1, %rax          # add the count of postive numbers

RemComp3:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd3              # if len > 0, then the work is not finished yet
	ret

RemAdd3:
    mrmovq 32(%rdi), %r11	# save the fifth element from memory to register %r11
    rmmovq %r10, 24(%rsi)	# save the value to the destination memory
    andq %r10, %r10         # test *src to see whether the value is less than 0
    jle RemComp4            # if not greater than 0, jump
    iaddq $1, %rax          # add the count of postive numbers

RemComp4:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd4              # if len > 0, then the work is not finished yet
	ret

RemAdd4:
    mrmovq 40(%rdi), %rcx	# save the sixth element from memory to register %rcx
    rmmovq %r11, 32(%rsi)	# save the value to the destination memory
    andq %r11, %r11         # test *src to see whether the value is less than 0
    jle RemComp5            # if not greater than 0, jump
    iaddq $1, %rax          # add the count of postive numbers

RemComp5:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd5              # if len > 0, then the work is not finished yet
	ret

RemAdd5:
    mrmovq 48(%rdi), %r8	# save the seventh element from memory to register %r8
    rmmovq %rcx, 40(%rsi)	# save the value to the destination memory
    andq %rcx, %rcx         # test *src to see whether the value is less than 0
    jle RemComp6            # if not greater than 0, jump
    iaddq $1, %rax          # add the count of postive numbers

RemComp6:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd6              # if len > 0, then the work is not finished yet
	ret

RemAdd6:
    mrmovq 56(%rdi), %r9	# save the seventh element from memory to register %r8
    rmmovq %r8, 48(%rsi)	# save the value to the destination memory
    andq %r8, %r8         # test *src to see whether the value is less than 0
    jle RemComp7            # if not greater than 0, jump
    iaddq $1, %rax          # add the count of postive numbers

RemComp7:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd7              # if len > 0, then the work is not finished yet
	ret

RemAdd7:
    rmmovq %r9, 56(%rsi)	# save the value to the destination memory
    andq %r9, %r9			# test *src to see whether the value is less than 0
    jle Done                # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad 1
	.quad -2
	.quad -3
	.quad 4
	.quad -5
	.quad -6
	.quad 7
	.quad -8
	.quad -9
	.quad -10
	.quad -11
	.quad 12
	.quad -13
	.quad 14
	.quad -15
	.quad -16
	.quad 17
	.quad -18
	.quad 19
	.quad -20
	.quad -21
	.quad 22
	.quad -23
	.quad 24
	.quad -25
	.quad -26
	.quad 27
	.quad 28
	.quad 29
	.quad 30
	.quad -31
	.quad 32
	.quad 33
	.quad 34
	.quad -35
	.quad -36
	.quad -37
	.quad 38
	.quad -39
	.quad 40
	.quad 41
	.quad 42
	.quad 43
	.quad -44
	.quad -45
	.quad 46
	.quad -47
	.quad -48
	.quad 49
	.quad -50
	.quad 51
	.quad 52
	.quad -53
	.quad -54
	.quad -55
	.quad -56
	.quad 57
	.quad -58
	.quad 59
	.quad 60
	.quad 61
	.quad 62
	.quad 63
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
