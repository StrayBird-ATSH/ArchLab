#######################################################################
# Test for copying block of size 63;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $63, %rdx		# src and dst have 63 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
	call ncopy		 
	halt			# should halt with num nonzeros in %rax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Wang, Chen
# 16307110064
#
# Describe how and why you modified the baseline code.
# The original baseline code is modified in great extension from the following 
# four perspectives:
# 1. The straightforward loop is unrolled into five continuous executions. 
# Therefore, if the data is longer than 5, each loop will do five continuous 
# copy actions, which can greatly reduce the number of iterations thus reducing 
# the condition control overhead.
# 2. There is usually the case that there are remainders that is not a multiple 
# of 5. In this case, I just made the copy execution in a straight line way 
# without any iterations. This can reduce the control overhead for this part.
# 3. Each condition jump is placed and designed carefully to make the prediction 
# have the best correct possibilities.
# 4. For the remaining parts, avoiding data hazard is also paid attention to
# so as to elevate the efficiency.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
# Loop header

Continue:
    iaddq $-4, %rdx         # len = len - 4
	jg Loop                 # if len > 0, then go to Loop

Remaining:
    iaddq $4, %rdx
    jg Continue1
    ret

Continue1:
    mrmovq (%rdi), %rcx		# save the first element from memory to register %rcx

    iaddq $-1, %rdx         # len = len - 1
    jg RemAddFirstNotEnd          # if len > 0, then the work is not finished yet


RemAddFirstEnd:
        rmmovq %rcx, (%rsi)		# save the value to the destination memory
        andq %rcx, %rcx			# test *src to see whether the value is less than 0
        jle Done             # if not greater than 0, jump
        iaddq $1, %rax			# add the count of postive numbers
    	ret

RemAddFirstNotEnd:

    rmmovq %rcx, (%rsi)		# save the value to the destination memory
    andq %rcx, %rcx			# test *src to see whether the value is less than 0
    jle RemAdd1             # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

RemAdd1:
    mrmovq 8(%rdi), %r8		# save the second element from memory to register %r8
    mrmovq 16(%rdi), %r9		# save the first element from memory to register %rcx
    rmmovq %r8, 8(%rsi)		# save the value to the destination memory
    andq %r8, %r8			# test *src to see whether the value is less than 0
    jle RemComp2             # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

RemComp2:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd2          # if len > 0, then the work is not finished yet
	ret

RemAdd2:
    mrmovq 24(%rdi), %r10		# save the first element from memory to register %rcx
    rmmovq %r9, 16(%rsi)		# save the value to the destination memory
    andq %r9, %r9			# test *src to see whether the value is less than 0
    jle RemComp3             # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers

RemComp3:
    iaddq $-1, %rdx         # len = len - 1
	jg RemAdd3          # if len > 0, then the work is not finished yet
	ret

RemAdd3:

    rmmovq %r10, 24(%rsi)		# save the value to the destination memory
    andq %r10, %r10			# test *src to see whether the value is less than 0
    jle Done             # if not greater than 0, jump
    iaddq $1, %rax			# add the count of postive numbers
	ret

########-----Loop Separator-------################################


Loop:
	mrmovq (%rdi), %rcx	    # save the first element from memory to register %rcx
	iaddq $40, %rdi		    # src = src + 5 (move 40 bytes, i.e. 5 words forward)
	iaddq $40, %rsi			# dst = dst + 5 (move 40 bytes, i.e. 5 words forward)
	mrmovq -32(%rdi), %r8	# save the second element from memory to register %r8
	rmmovq %rcx, -40(%rsi)  # save the value to the destination memory
	andq %rcx, %rcx		    # test %rcx
	jle ADD1			    # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax		    # add the number of postive numbers
ADD1:
	mrmovq -24(%rdi), %r9  # to avoid load/use hazard, this read memory instruction is advanced
	rmmovq %r8, -32(%rsi)	# save the second value to the destination memory
	andq %r8, %r8			# test for future reference
	mrmovq -16(%rdi), %r10  # to avoid load/use hazard, this read memory instruction is advanced
	jle ADD2				# if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax			# add the number of postive numbers
ADD2:
	rmmovq %r9, -24(%rsi)  # save the third value to the destination memory
	andq %r9, %r9         # test for future reference
	mrmovq -8(%rdi), %r11   # to avoid load/use hazard, this read memory instruction is advanced
	jle ADD3                # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers
ADD3:
	rmmovq %r10, -16(%rsi)  # save the forth value to the destination memory
	andq %r10, %r10         # test for future reference
	jle ADD4                # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers
ADD4:
	rmmovq %r11, -8(%rsi)   # save the fifth value to the destination memory
	andq %r11, %r11         # test to see if the value is no greater than 0
	jle ADD5
	iaddq $1, %rax          # add the number of postive numbers
ADD5:
	iaddq $-5, %rdx			# len -= 5 if(len - 4 > 0) that means len > 4
	jg Loop					# if so, goto Loop:
    jmp Remaining

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad -1
	.quad 2
	.quad 3
	.quad 4
	.quad -5
	.quad 6
	.quad -7
	.quad -8
	.quad -9
	.quad 10
	.quad -11
	.quad -12
	.quad 13
	.quad 14
	.quad 15
	.quad 16
	.quad -17
	.quad -18
	.quad 19
	.quad 20
	.quad 21
	.quad -22
	.quad -23
	.quad -24
	.quad -25
	.quad 26
	.quad 27
	.quad 28
	.quad -29
	.quad 30
	.quad -31
	.quad -32
	.quad -33
	.quad -34
	.quad 35
	.quad 36
	.quad -37
	.quad 38
	.quad -39
	.quad 40
	.quad -41
	.quad -42
	.quad 43
	.quad -44
	.quad -45
	.quad 46
	.quad -47
	.quad -48
	.quad -49
	.quad 50
	.quad 51
	.quad -52
	.quad -53
	.quad -54
	.quad -55
	.quad -56
	.quad 57
	.quad 58
	.quad 59
	.quad 60
	.quad 61
	.quad 62
	.quad 63
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
