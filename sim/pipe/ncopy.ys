#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Wang, Chen
# 16307110064
#
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
# Loop header
    xorq %rax,%rax          # count = 0;
    iaddq $-4, %rdx         # len = len - 4
	jg Loop                 # if len > 0, then go to Loop

Restore:
	iaddq $4, %rdx          # The value is mispredictedly substracted from len, thus make up the value here
Rest:
	jg NotFinished          # if len > 0, then the work is not finished yet
	ret
NotFinished:
	mrmovq (%rdi), %rcx		# save the first element from memory to register %rcx
	iaddq $8, %rdi          # src = src + 1 (move 8 bytes, i.e. 1 word forward)
	andq %rcx, %rcx			# test *src to see whether the value is less than 0
	jle ADD 				# if not greater than 0, jump
	iaddq $1, %rax			# add the count of postive numbers
ADD:
	rmmovq %rcx, (%rsi)		# save the value to the destination memory
	iaddq $8, %rsi          # dst = dst + 1 (move 8 bytes, i.e. 1 word forward)
	iaddq $-1, %rdx         # len = len - 1
	jmp Rest                # See whether len > 0
Loop:
	mrmovq (%rdi), %rcx	    # save the first element from memory to register %rcx
	iaddq $40, %rdi		    # src = src + 5 (move 40 bytes, i.e. 5 words forward)
	rmmovq %rcx, (%rsi)     # save the value to the destination memory
	andq %rcx, %rcx		    # test %rcx
	jle ADD1			    # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax		    # add the number of postive numbers
ADD1:
	mrmovq -32(%rdi), %rcx	# save the second element from memory to register %rcx
	iaddq $40, %rsi			# dst = dst + 5 (move 40 bytes, i.e. 5 words forward)
	rmmovq %rcx, -32(%rsi)	# save the second value to the destination memory
	andq %rcx, %rcx			# test for future reference
	mrmovq -24(%rdi), %rcx  # to avoid load/use hazard, this read memory instruction is advanced
	jle ADD2				# if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax			# add the number of postive numbers
ADD2:
	rmmovq %rcx, -24(%rsi)  # save the third value to the destination memory
	andq %rcx, %rcx         # test for future reference
	mrmovq -16(%rdi), %rcx  # to avoid load/use hazard, this read memory instruction is advanced
	jle ADD3                # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers
ADD3:
	rmmovq %rcx, -16(%rsi)  # save the forth value to the destination memory
	andq %rcx, %rcx         # test for future reference
	mrmovq -8(%rdi), %rcx   # to avoid load/use hazard, this read memory instruction is advanced
	jle ADD4                # if the value is no greater than 0, then do not increment %rax
	iaddq $1, %rax          # add the number of postive numbers
ADD4:
	rmmovq %rcx, -8(%rsi)   # save the fifth value to the destination memory
	andq %rcx, %rcx         # test to see if the value is no greater than 0
	jle ADD5
	iaddq $1, %rax          # add the number of postive numbers
ADD5:
	iaddq $-5, %rdx			# len -= 5 if(len - 4 > 0) that means len > 4
	jg Loop					# if so, goto Loop:
	jmp Restore
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
